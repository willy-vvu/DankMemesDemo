<!DOCTYPE html>
<html>
  <head>
  </head>
  <body style="margin:0;overflow:hidden">
    <script src="three.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="SceneLoader.js"></script>
    <script src="coffee-script.js"></script>
    <script type="text/coffeescript">
      # A quick utility
      find = (array, name)->
        for obj in array when obj.name is name
          return obj
      
      # Set things up
      renderer=new THREE.WebGLRenderer()
      renderer.setSize(window.innerWidth,window.innerHeight)
      document.body.appendChild(renderer.domElement)
      loader = new THREE.ObjectLoader()
      loader.load "../Step 3/Scene.json", (data)->
        # Setup scene
        window.scene = data
        loader = new THREE.JSONLoader()
        loader.load "../Step 3/Aurora.json", (geometry)->
          # All the loading is complete. The coding can begin.
          # Setup Aurora
          auroraTexture = THREE.ImageUtils.loadTexture("../Step 3/Aurora.png")
          # Be sure to sort the faces in blender, or else strange artifacts ensue!
          aurora = new THREE.SkinnedMesh(geometry, new THREE.MeshBasicMaterial(side: THREE.DoubleSide, skinning: true, transparent: true, map: auroraTexture))
          aurora.rotation.y = -Math.PI/2
          #aurora.scale.x = 10
          aurora.position.z = 0.1
          wind = new THREE.Animation(aurora, find(aurora.geometry.animations,"Wind"))
          #wind.play()

          # Setup animations
          currentAnimation = "idle"
          animations = {
            land: new THREE.Animation(aurora, find(aurora.geometry.animations,"Landing")),
            idle: new THREE.Animation(aurora, find(aurora.geometry.animations,"Idle")),
            walk: new THREE.Animation(aurora, find(aurora.geometry.animations,"Walk")),
            hover: new THREE.Animation(aurora, find(aurora.geometry.animations,"Hover"))
            flyforwards: new THREE.Animation(aurora, find(aurora.geometry.animations,"Fly Forwards"))
            flyupwards: new THREE.Animation(aurora, find(aurora.geometry.animations,"Fly Upwards"))
            fall: new THREE.Animation(aurora, find(aurora.geometry.animations,"Fall"))
            dance: new THREE.Animation(aurora, find(aurora.geometry.animations,"Dance - 132bpm"))
          }
          landing = 0
          animations[currentAnimation].play()

          scene.add(aurora)
          sdebug = new THREE.SkeletonHelper(aurora)
          scene.add(sdebug)
          # Turn this off to see the skeleton visualized
          sdebug.visible = false

          # Setup the camera
          aspect = window.innerWidth/window.innerHeight
          camera = new THREE.PerspectiveCamera(45 / Math.max(16/9, aspect),aspect,10,80)
          camera.position.set(0, 4.5, 26.5)
          # window.addEventListener "mousemove", (event)->
          #   camera.position.set(
          #     3 * (event.pageX/window.innerWidth - 0.5),
          #     3 * (-event.pageY/window.innerHeight + 0.5) + 4.5, 26.5)
          # controls = new THREE.OrbitControls( camera )
          # controls.noKeys = true
          # controls.damping = 0.2
          scene.add(camera)

          # Create and assign textures
          backdropTexture = THREE.ImageUtils.loadTexture("../Step 3/Backdrop Packed.png")
          scene.children[0].material = 
          scene.children[2].material = 
          scene.children[1].material = 
          scene.children[3].material = new THREE.MeshBasicMaterial(transparent: true, map: backdropTexture)
          backdropTexture2 = THREE.ImageUtils.loadTexture("../Step 3/Backdrop Packed 2.png")
          scene.children[4].material = 
          scene.children[5].material = 
          scene.children[6].material = new THREE.MeshBasicMaterial(transparent: true, map: backdropTexture2)

          velocity = new THREE.Vector3()
          joystick = new THREE.Vector3()
          tempVector = new THREE.Vector3()

          # Gotta handle those keys
          keyMap = {
            up: 0
            down: 0
            left: 0
            right: 0
            dance: 0
          }
          handleKey = (keyCode, down)->
            switch keyCode
              when 37 #Left
                keyMap.left = down
              when 38 #Up
                keyMap.up = down
              when 39 #Right
                keyMap.right = down
              when 40 #Down
                keyMap.down = down
              when 192
                keyMap.dance = down

          window.addEventListener "keydown", (event)->
            handleKey(event.keyCode, 1)
          window.addEventListener "keyup", (event)->
            handleKey(event.keyCode, 0)

          do render = ()->

            # Normalize all the weights, blend between animations, and update the animaitons.
            wind.resetBlendWeights()
            animations[currentAnimation].weight = currentWeight = Math.min(1, animations[currentAnimation].weight + 0.05)
            weightSum = 0
            for anim of animations
              animations[anim].resetBlendWeights()
              if animations[anim].weight<0.01
                animations[anim].weight = 0
              if anim isnt currentAnimation
                weightSum += animations[anim].weight
            for anim of animations
              #console.log ("#{anim}, #{animations[anim].weight}")
              if anim isnt currentAnimation and weightSum isnt 0
                animations[anim].weight *= (1-currentWeight)/weightSum
              animations[anim].update(if anim is currentAnimation then 1/60 else 0)
            wind.update(1/60)
            sdebug.update()

            joystick.set(
              keyMap.right - keyMap.left,
              keyMap.up - keyMap.down, 0
            )
            
            # Let's get physical
            lastTouchingGround = aurora.position.y < 0.01
            
            targetVel = tempVector.copy(joystick).multiplyScalar(if lastTouchingGround then 0.15 else 0.25)
            velocity.lerp(targetVel, 0.1)
            aurora.position.add(velocity)
            aurora.position.x = Math.min(Math.max(aurora.position.x, -14), 14)
            aurora.position.y = Math.min(Math.max(aurora.position.y, 0), 12)
            
            touchingGround = aurora.position.y < 0.01

            # Find the next animation to transition to
            if touchingGround
              if not lastTouchingGround
                landing = 10
              nextAnimation = if joystick.x is 0 then "idle" else "walk"
            else
              if joystick.x isnt 0
                nextAnimation = "flyforwards"
              else
                nextAnimation = if joystick.y > 0 then "flyupwards" else (if joystick.y < 0 then "fall" else "hover")

            if landing>0
              landing--
              nextAnimation = "land"
            if keyMap.dance isnt 0
              nextAnimation = "dance"

            if nextAnimation isnt currentAnimation
              animations[nextAnimation].play(0, 0)
              currentAnimation = nextAnimation

            # Ability to turn around
            if aurora.scale.z > 0
              if velocity.x<0
                aurora.scale.z = -1
            else if aurora.scale.z < 0
              if velocity.x>0
                aurora.scale.z = 1

            # Let the camera follow Aurora, and render!
            camera.position.set(
              1.5 * Math.max(Math.min(aurora.position.x/10,1),-1),
              3.5 * Math.max(Math.min(aurora.position.y/8,1),0) + 3, 26.5)
            renderer.render(scene, camera)
            window.requestAnimationFrame(render)

          window.addEventListener "resize", ()->
            renderer.setSize(window.innerWidth, window.innerHeight)
            camera.aspect = window.innerWidth/window.innerHeight
            camera.fov = 45 / Math.max(16/9, camera.aspect)
            camera.updateProjectionMatrix()
      

    </script>
  </body>
</html>